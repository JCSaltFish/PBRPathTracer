#ifndef __compte_shader_h__
#define __compte_shader_h__

#include <string>

const std::string compPt = 
{
"#version 450\n"

"layout(local_size_x = 32, local_size_y = 32) in;\n"

"layout(binding = 0, rgba32f) uniform image2D imgOut;\n"

"layout(binding = 1) uniform PathTracerUniforms\n"
"{\n"
"    ivec2 resolution;\n"
"    int maxDepth;\n"
"    int samples;\n"
"} PathTracer;\n"

"layout(binding = 2) uniform CameraUniforms\n"
"{\n"
"    vec4 camPos;\n"
"    vec4 camDir;\n"
"    vec4 camUp;\n"
"    float camFocal;\n"
"    float camFovy;\n"
"	float camFocalDist;\n"
"	float camAperture;\n"
"} Camera;\n"

"struct Material\n"
"{\n"
"	vec4 diffuse;\n"
"	vec4 specular;\n"
"	vec4 emissive;\n"

"	float emissIntensity;\n"
"	float roughness;\n"
"	float reflectiveness;\n"
"	float translucency;\n"

"	float ior;\n"
"	int translucent;\n"
"	int diffuseTexId;\n"
"	int normalTexId;\n"

"	int emissTexId;\n"
"	int roughnessTexId;\n"
"	int metallicTexId;\n"
"	int opacityTexId;\n"
"};\n"

"layout(std430, binding = 3) restrict readonly buffer MATERIALS\n"
"{\n"
"	Material materials[];\n"
"};\n"

"struct Triangle\n"
"{\n"
"	vec4 v1;\n"
"	vec4 v2;\n"
"	vec4 v3;\n"
"	vec4 n1;\n"
"	vec4 n2;\n"
"	vec4 n3;\n"
"	vec4 normal;\n"
"	vec4 tangent;\n"
"	vec4 bitangent;\n"

"	vec2 uv1;\n"
"	vec2 uv2;\n"

"	vec2 uv3;\n"
"	int objectId;\n"
"	int elementId;\n"

"	vec4 barycentric_v0;\n"
"	vec4 barycentric_v1;\n"

"	float barycentric_d00;\n"
"	float barycentric_d01;\n"
"	float barycentric_d11;\n"
"	float barycentric_invDenom;\n"

"	int smoothing;\n"
"	int id;\n"
"	int materialId;\n"
"	int padding;\n"
"};\n"

"layout(std430, binding = 4) restrict readonly buffer TRIANGLES\n"
"{\n"
"	Triangle triangles[];\n"
"};\n"

"struct BVHNode\n"
"{\n"
"    int nodeIndex;\n"
"	int rightOffset;\n"
"	int triangleId;\n"
"	int padding;\n"

"	vec4 aabb_min;\n"
"	vec4 aabb_max;\n"
"};\n"

"layout(std430, binding = 5) restrict readonly buffer BVH\n"
"{\n"
"	BVHNode nodes[];\n"
"};\n"

"layout(std430, binding = 6) restrict readonly buffer LIGHTS\n"
"{\n"
"	int lightsources[];\n"
"};\n"
"layout(location = 0) uniform int numLightsources;\n"

"layout(location = 1) uniform sampler2DArray textures;\n"
"layout(std430, binding = 7) restrict readonly buffer TEX_SIZES\n"
"{\n"
"	ivec2 texSizes[];\n"
"};\n"

"const float PI = 3.141592654;\n"
"const float EPSILON = 0.001;\n"

"float randSeed;\n"
"vec2 randState;\n"
"float Rand()\n"
"{\n"
"	randSeed++;\n"
"    return fract(sin(randSeed / PathTracer.samples * dot(randState, vec2(12.9898, 78.233))) * 43758.5453);\n"
"}\n"

"vec2 GetUV(vec3 p, int nodeIndex)\n"
"{\n"
"	Triangle t = triangles[nodes[nodeIndex].triangleId];\n"
"	vec3 v2 = p - t.v1.xyz;\n"
"	float d20 = dot(v2, t.barycentric_v0.xyz);\n"
"	float d21 = dot(v2, t.barycentric_v1.xyz);\n"

"	float alpha = (t.barycentric_d11 * d20 - t.barycentric_d01 * d21) * t.barycentric_invDenom;\n"
"	float beta = (t.barycentric_d00 * d21 - t.barycentric_d01 * d20) * t.barycentric_invDenom;\n"

"	return (1.0 - alpha - beta) * t.uv1 + alpha * t.uv2 + beta * t.uv3;\n"
"}\n"

"vec3 GetSmoothNormal(vec3 p, int nodeIndex)\n"
"{\n"
"	Triangle t = triangles[nodes[nodeIndex].triangleId];\n"
"	vec3 v2 = p - t.v1.xyz;\n"
"	float d20 = dot(v2, t.barycentric_v0.xyz);\n"
"	float d21 = dot(v2, t.barycentric_v1.xyz);\n"

"	float alpha = (t.barycentric_d11 * d20 - t.barycentric_d01 * d21) * t.barycentric_invDenom;\n"
"	float beta = (t.barycentric_d00 * d21 - t.barycentric_d01 * d20) * t.barycentric_invDenom;\n"

"	vec3 n = (1.0 - alpha - beta) * t.n1.xyz + alpha * t.n2.xyz + beta * t.n3.xyz;\n"
"	vec3 res = normalize(vec3(n.x, -n.y, n.z));\n"
"	return normalize(n);\n"
"}\n"

"bool IsSameSide(vec3 p1, vec3 p2, vec3 a, vec3 b)\n"
"{\n"
"    vec3 ba = b - a;\n"
"	vec3 cp1 = cross(ba, (p1 - a));\n"
"	vec3 cp2 = cross(ba, (p2 - a));\n"
"	return (dot(cp1, cp2) >= 0);\n"
"}\n"
"bool IntersectTriangle(vec3 p, vec3 a, vec3 b, vec3 c)\n"
"{\n"
"    return (IsSameSide(p, a, b, c) && IsSameSide(p, b, a, c) && IsSameSide(p, c, a, b));\n"
"}\n"

"bool IntersectBox(vec3 ro, vec3 rd, vec3 bMin, vec3 bMax)\n"
"{\n"
"    vec3 tMin = (bMin - ro) / rd;\n"
"	vec3 tMax = (bMax - ro) / rd;\n"
"	vec3 t1 = min(tMin, tMax);\n"
"	vec3 t2 = max(tMin, tMax);\n"
"	float tNear = max(max(t1.x, t1.y), t1.z);\n"
"	float tFar = min(min(t2.x, t2.y), t2.z);\n"
"	if (tNear >= tFar)\n"
"		return false;\n"
"	return true;\n"
"}\n"

"bool Hit(vec3 ro, vec3 rd, out int nodeIndex, out float dist)\n"
"{\n"
"    bool result = false;\n"

"    dist = float(0xFFFF);\n"

"    int stack[64];\n"
"    int pStack = 0;\n"
"    stack[pStack++] = -1;\n"

"    int currIndex = 0;\n"
"    do\n"
"    {\n"
"        if (IntersectBox(ro, rd, nodes[currIndex].aabb_min.xyz, nodes[currIndex].aabb_max.xyz))\n"
"        {\n"
"            if (nodes[currIndex].rightOffset == -1) // leaf\n"
"            {\n"
"				Triangle t = triangles[nodes[currIndex].triangleId];\n"
"                if (dot(rd, t.normal.xyz) != 0.0)\n"
"				{\n"
"					float d = dot((t.v1.xyz - ro), t.normal.xyz) / dot(rd, t.normal.xyz);\n"
"					if (d >= 0)\n"
"					{\n"
"						vec3 p = ro + rd * d;\n"
"						if (IntersectTriangle(p, t.v1.xyz, t.v2.xyz, t.v3.xyz))\n"
"						{\n"
"							// Opacity\n"
"							bool tmpResult = true;\n"
"							int opacTexId = materials[t.materialId].opacityTexId;\n"
"							if (opacTexId != -1)\n"
"							{\n"
"								vec2 uv = GetUV(p, currIndex);\n"
"								vec2 texCoord = uv * texSizes[opacTexId] /\n"
"									textureSize(textures, 0).xy;\n"
"								float opacity = texture(textures, vec3(texCoord, opacTexId)).r;\n"
"								tmpResult = Rand() < opacity;\n"
"							}\n"

"							if (d < dist && tmpResult)\n"
"							{\n"
"								dist = d;\n"
"								nodeIndex = currIndex;\n"
"								result = true;\n"
"							}\n"
"						}\n"
"					}\n"
"				}\n"
"                currIndex = stack[--pStack];\n"
"            }\n"
"            else // interier\n"
"            {\n"
"                int left = nodes[currIndex].nodeIndex + 1;\n"
"                int right = nodes[currIndex].nodeIndex + nodes[currIndex].rightOffset;\n"
"                currIndex = left;\n"
"                stack[pStack++] = right;\n"
"            }\n"
"        }\n"
"        else\n"
"            currIndex = stack[--pStack];\n"
"    }\n"
"    while (pStack > 0 && pStack < 64);\n"

"    return result;\n"
"}\n"

"vec3 SampleTriangle(vec3 v0, vec3 v1, vec3 v2)\n"
"{\n"
"	float u = sqrt(Rand());\n"
"	float v = Rand();\n"
"	float w0 = 1. - u;\n"
"	float w1 = u * (1. - v);\n"
"	float w2 = u * v;\n"
"	return w0 * v0 + w1 * v1 + w2 * v2;\n"
"}\n"

"vec3 DirectIllumimation(vec3 rd, vec3 p, vec3 n, vec3 diffuse)\n"
"{\n"
"	// sample a light triangle\n"
"	int lightId = int(floor(Rand() * numLightsources));\n"
"	if (lightId == numLightsources && lightId > 0)\n"
"		lightId--;\n"
"	Triangle tLight = triangles[lightsources[lightId]];\n"
"	// sample a point inside the triangle\n"
"	vec3 vLight = SampleTriangle(tLight.v1.xyz, tLight.v2.xyz, tLight.v3.xyz);\n"
"	// evaluate the shadow ray\n"
"	vec3 l = normalize(vLight - p);\n"
"	if (dot(-n, -l) <= 0.)\n"
"	return vec3(0.);\n"
"	float d = 0.0;\n"
"    int nodeIndex = -1;\n"
"	if (Hit(p, l, nodeIndex, d))\n"
"	{\n"
"		if (tLight.id != nodes[nodeIndex].triangleId)\n"
"			return vec3(0.);\n"
"	}\n"

"	Material mLight = materials[tLight.materialId];\n"
"	vec3 lColor = mLight.emissive.rgb * mLight.emissIntensity;\n"

"	return lColor * diffuse * dot(-n, -l);\n"
"}\n"

"vec4 Trace(vec3 ro, vec3 rd)\n"
"{\n"
"    vec3 color = vec3(0.);\n"

"    bool inside = false;\n"
"    vec3 atten = vec3(1.);\n"
"	int maxDepth = PathTracer.maxDepth;\n"
"    for (int i = 0; i < maxDepth; i++)\n"
"    {\n"
"        float d = 0.0;\n"
"        int nodeIndex = -1;\n"
"        if (Hit(ro, rd, nodeIndex, d))\n"
"        {\n"
"			Triangle t = triangles[nodes[nodeIndex].triangleId];\n"
"			Material m = materials[t.materialId];\n"

"            vec3 p = ro + rd * d;\n"
"            vec2 uv = GetUV(p, nodeIndex);\n"
"            vec3 n = t.normal.xyz;\n"
"            if (t.smoothing == 1)\n"
"			    n = GetSmoothNormal(p, nodeIndex);\n"
"            if (m.normalTexId != -1)\n"
"		    {\n"
"			    mat3 TBN = mat3(t.tangent.xyz, t.bitangent.xyz, n);\n"
"				vec2 texCoord = uv * texSizes[m.normalTexId] / textureSize(textures, 0).xy;\n"
"				vec3 nt = texture(textures, vec3(texCoord, m.normalTexId)).rgb * 2.0 - 1.0;\n"
"			    if (nt.z <= 0.)\n"
"				    nt = vec3(nt.x, nt.y, EPSILON);\n"
"			    nt = normalize(nt);\n"
"				n = normalize(TBN * nt);\n"
"		    }\n"
"		    if (dot(n, rd) > 0.)\n"
"			    n = -n;\n"
"		    p += n * EPSILON;\n"
"			\n"
"			vec3 diffuse = m.diffuse.rgb;\n"
"			if (m.diffuseTexId != -1)\n"
"			{\n"
"				vec2 texCoord = uv * texSizes[m.diffuseTexId] / textureSize(textures, 0).xy;\n"
"				diffuse = texture(textures, vec3(texCoord, m.diffuseTexId)).rgb;\n"
"			}\n"
"			vec3 emiss = m.emissive.rgb;\n"
"			if (m.emissTexId != -1)\n"
"			{\n"
"				vec2 texCoord = uv * texSizes[m.emissTexId] / textureSize(textures, 0).xy;\n"
"				emiss = texture(textures, vec3(texCoord, m.emissTexId)).rgb;\n"
"			}\n"
"			float roughness = m.roughness;\n"
"			if (m.roughnessTexId != -1)\n"
"			{\n"
"				vec2 texCoord = uv * texSizes[m.roughnessTexId] / textureSize(textures, 0).xy;\n"
"				roughness = texture(textures, vec3(texCoord, m.roughnessTexId)).r;\n"
"			}\n"
"			float reflectiveness = m.reflectiveness;\n"
"			if (m.metallicTexId != -1)\n"
"			{\n"
"				vec2 texCoord = uv * texSizes[m.metallicTexId] / textureSize(textures, 0).xy;\n"
"				reflectiveness = texture(textures, vec3(texCoord, m.metallicTexId)).r;\n"
"			}\n"

"            vec3 r = reflect(rd, n);\n"
"            vec3 reflectDir = r;\n"

"            if (m.translucent == 0)\n"
"            {\n"
"                if (Rand() < reflectiveness)\n"
"				{\n"
"					if (roughness == 1.)\n"
"					{\n"
"						// uniformly sampling on hemisphere\n"
"						vec3 u = abs(n.x) < 1. - EPSILON ? cross(vec3(1.,0.,0.), n) : cross(vec3(1.), n);\n"
"						u = normalize(u);\n"
"						vec3 v = normalize(cross(u, n));\n"
"						float w = Rand(), theta = Rand();\n"
"						reflectDir = w * cos(2. * PI * theta) * u + w * sin(2. * PI * theta) * v + sqrt(1. - w * w) * n;\n"
"						reflectDir = normalize(reflectDir);\n"
"					}\n"
"					else if (roughness == 0.)\n"
"						reflectDir = r;\n"
"					else\n"
"					{\n"
"						// wighted sampling on hemisphere\n"
"						vec3 u = abs(n.x) < 1. - EPSILON ? cross(vec3(1.,0.,0.), r) : cross(vec3(1.), r);\n"
"						u = normalize(u);\n"
"						vec3 v = normalize(cross(u, r));\n"
"						float w = Rand() * roughness, theta = Rand();\n"
"						reflectDir = w * cos(2. * PI * theta) * u + w * sin(2. * PI * theta) * v + sqrt(1. - w * w) * r;\n"
"						reflectDir = normalize(reflectDir);\n"
"					}\n"
"					\n"
"					color += emiss.xyz * m.emissIntensity * atten;\n"
"                    ro = p;\n"
"                    rd = reflectDir;\n"
"                    atten *= m.specular.xyz;\n"
"					maxDepth++;\n"
"				}\n"
"                else\n"
"				{\n"
"					// uniformly sampling on hemisphere\n"
"					vec3 u = abs(n.x) < 1. - EPSILON ? cross(vec3(1.,0.,0.), n) : cross(vec3(1.), n);\n"
"					u = normalize(u);\n"
"					vec3 v = normalize(cross(u, n));\n"
"					float w = Rand(), theta = Rand();\n"
"					reflectDir = w * cos(2. * PI * theta) * u + w * sin(2. * PI * theta) * v + sqrt(1. - w * w) * n;\n"
"					reflectDir = normalize(reflectDir);\n"

"                    color += DirectIllumimation(rd, p, n, diffuse) * atten;\n"
"					color += emiss.xyz * m.emissIntensity * atten;\n"
"                    ro = p;\n"
"                    rd = reflectDir;\n"
"                    atten *= diffuse;\n"
"				}\n"
"            }\n"
"            else\n"
"            {\n"
"                bool bRefract = false;\n"
"				vec3 refractN = n;\n"
"				if (roughness != 0.)\n"
"				{\n"
"					// wighted sampling on hemisphere\n"
"					vec3 u = abs(n.x) < 1. - EPSILON ? cross(vec3(1.,0.,0.), r) : cross(vec3(1.), r);\n"
"					u = normalize(u);\n"
"					vec3 v = normalize(cross(u, r));\n"
"					float w = Rand() * roughness, theta = Rand();\n"
"					refractN = w * cos(2. * PI * theta) * u + w * sin(2. * PI * theta) * v + sqrt(1. - w * w) * n;\n"
"					refractN = normalize(refractN);\n"
"				}\n"

"                float nc = 1., ng = m.ior;\n"
"				// Snells law\n"
"				float eta = inside ? ng / nc : nc / ng;\n"
"				float r0 = (nc - ng) / (nc + ng);\n"
"				r0 = r0 * r0;\n"
"				float c = abs(dot(rd, refractN));\n"
"				float k = 1. - eta * eta * (1. - c * c);\n"
"				if (k < 0.)\n"
"					bRefract = false;\n"
"				else\n"
"				{\n"
"					// Shilick's approximation of Fresnel's equation\n"
"					float re = r0 + (1. - r0) * (1. - c) * (1. - c);\n"
"					if (abs(Rand()) < re)\n"
"						bRefract = false;\n"
"					else if (Rand() < reflectiveness)\n"
"						bRefract = false;\n"
"					else\n"
"						bRefract = true;\n"
"				}\n"

"				maxDepth++;\n"
"                if (!bRefract)\n"
"				{\n"
"					if (roughness == 1.)\n"
"					{\n"
"						// uniformly sampling on hemisphere\n"
"						vec3 u = abs(n.x) < 1. - EPSILON ? cross(vec3(1.,0.,0.), n) : cross(vec3(1.), n);\n"
"						u = normalize(u);\n"
"						vec3 v = normalize(cross(u, n));\n"
"						float w = Rand(), theta = Rand();\n"
"						reflectDir = w * cos(2. * PI * theta) * u + w * sin(2. * PI * theta) * v + sqrt(1. - w * w) * n;\n"
"						reflectDir = normalize(reflectDir);\n"
"					}\n"
"					else if (roughness == 0.)\n"
"						reflectDir = r;\n"
"					else\n"
"					{\n"
"						// wighted sampling on hemisphere\n"
"						vec3 u = abs(n.x) < 1. - EPSILON ? cross(vec3(1.,0.,0.), r) : cross(vec3(1.), r);\n"
"						u = normalize(u);\n"
"						vec3 v = normalize(cross(u, r));\n"
"						float w = Rand() * roughness, theta = Rand();\n"
"						reflectDir = w * cos(2. * PI * theta) * u + w * sin(2. * PI * theta) * v + sqrt(1. - w * w) * r;\n"
"						reflectDir = normalize(reflectDir);\n"
"					}\n"

"					color += emiss.xyz * m.emissIntensity * atten;\n"
"                    ro = p;\n"
"                    rd = reflectDir;\n"
"                    atten *= m.specular.xyz;\n"
"				}\n"
"				else\n"
"				{\n"
"					if (Rand() < m.translucency)\n"
"					{\n"
"						reflectDir = normalize(eta * rd - (eta * dot(n, rd) + sqrt(k)) * refractN);\n"
"						p -= n * EPSILON * 2.;\n"
"						inside = !inside;\n"

"						color += emiss.xyz * m.emissIntensity * atten;\n"
"						ro = p;\n"
"						rd = reflectDir;\n"
"						atten *= diffuse;\n"
"					}\n"
"					else\n"
"					{\n"
"						// uniformly sampling on hemisphere\n"
"						vec3 u = abs(n.x) < 1. - EPSILON ? cross(vec3(1.,0.,0.), n) : cross(vec3(1.), n);\n"
"						u = normalize(u);\n"
"						vec3 v = normalize(cross(u, n));\n"
"						float w = Rand(), theta = Rand();\n"
"						reflectDir = w * cos(2. * PI * theta) * u + w * sin(2. * PI * theta) * v + sqrt(1. - w * w) * n;\n"
"						reflectDir = normalize(reflectDir);\n"

"						color += DirectIllumimation(rd, p, n, diffuse) * atten;\n"
"						color += emiss.xyz * m.emissIntensity * atten;\n"
"						ro = p;\n"
"						rd = reflectDir;\n"
"						atten *= diffuse;\n"
"					}\n"
"				}\n"
"            }\n"

"			// Russian Roulette Path Termination\n"
"			float prob = min(0.95, max(max(diffuse.r, diffuse.g), diffuse.b));\n"
"			if (i + 1 >= PathTracer.maxDepth)\n"
"			{\n"
"				if (abs(Rand()) > prob)\n"
"					break;\n"
"			}\n"
"        }\n"
"        else\n"
"            break;\n"
"    }\n"

"    return vec4(color, 1.);\n"
"}\n"

"vec2 SampleCircle()\n"
"{\n"
"	float angle = Rand() * 2. * PI;\n"
"	float radius = sqrt(Rand());\n"
"	return vec2(cos(angle), sin(angle)) * radius;\n"
"}\n"

"void main()\n"
"{\n"
"	uint x = gl_GlobalInvocationID.x;\n"
"    uint y = gl_GlobalInvocationID.y;\n"
"    if (x >= PathTracer.resolution.x || y >= PathTracer.resolution.y)\n"
"        return;\n"

"    // Position world space image plane\n"
"    vec3 imgCenter = Camera.camPos.xyz + Camera.camDir.xyz * Camera.camFocal;\n"
"    float imgHeight = 2. * Camera.camFocal * tan((Camera.camFovy / 2.) * PI / 180.);\n"
"    float aspect = float(PathTracer.resolution.x) / float(PathTracer.resolution.y);\n"
"    float imgWidth = imgHeight * aspect;\n"
"    float deltaX = imgWidth / float(PathTracer.resolution.x);\n"
"    float deltaY = imgHeight / float(PathTracer.resolution.y);\n"
"    vec3 camRight = normalize(cross(Camera.camUp.xyz, Camera.camDir.xyz));\n"

"    vec3 topLeft = imgCenter - camRight * (imgWidth * 0.5);\n"
"    topLeft += Camera.camUp.xyz * (imgHeight * 0.5f);\n"
"    vec3 pixel = topLeft - Camera.camUp.xyz * (float(y) * deltaY) + camRight * (float(x) * deltaX);\n"
"	\n"
"	y = PathTracer.resolution.y - y - 1;\n"
"    vec2 fragCoord = vec2(float(x) / float(PathTracer.resolution.x), float(y) / float(PathTracer.resolution.y));\n"
"	\n"
"	vec3 camPos = Camera.camPos.xyz;\n"
"    vec3 rayDir = normalize(pixel - camPos);\n"
"	randState = vec2(x, y);\n"

"	// DOF\n"
"	vec3 focalPoint = camPos + rayDir * Camera.camFocalDist;\n"
"	vec2 camPosOffset = SampleCircle() * Camera.camAperture;\n"
"	camPos += camRight * camPosOffset.x + Camera.camUp.xyz * camPosOffset.y;\n"
"	rayDir = normalize(focalPoint - camPos);\n"

"    int depth = 0;\n"
"    vec4 color = Trace(camPos, rayDir);\n"

"    // Draw\n"
"	if (PathTracer.samples != 1)\n"
"	{\n"
"		color += vec4(imageLoad(imgOut, ivec2(x, y)).rgb * (PathTracer.samples - 1), 0.);\n"
"		barrier();\n"
"	}\n"
"	imageStore(imgOut, ivec2(x, y), vec4(color.rgb / float(PathTracer.samples), 1.));\n"
"}\n"
};

#endif
